import os

# Create basicsr.utils directory
os.makedirs('/dbfs/FileStore/VideoReTalking/basicsr/utils', exist_ok=True)

# Empty __init__.py
with open('/dbfs/FileStore/VideoReTalking/basicsr/utils/__init__.py', 'w') as f:
    f.write('from .misc import scandir\n')

# Create minimal scandir function (used by GFPGAN to find files)
misc_code = '''
import os
from pathlib import Path

def scandir(dir_path, suffix=None, recursive=False, full_path=False):
    """Scan a directory to find files with given suffix.
    
    Args:
        dir_path (str | Path): Path of the directory.
        suffix (str | tuple(str), optional): File suffix. Default: None.
        recursive (bool, optional): If True, recursively scan subdirectories. Default: False.
        full_path (bool, optional): If True, return full path. Default: False.
        
    Returns:
        list[str]: List of file paths.
    """
    if isinstance(dir_path, (str, Path)):
        dir_path = str(dir_path)
    else:
        raise TypeError('"dir_path" must be a string or Path object')

    if (suffix is not None) and not isinstance(suffix, (str, tuple)):
        raise TypeError('"suffix" must be a string or tuple of strings')

    root = dir_path

    def _scandir(dir_path, suffix, recursive):
        for entry in os.scandir(dir_path):
            if not entry.name.startswith('.') and entry.is_file():
                if suffix is None:
                    yield entry.path
                elif entry.name.endswith(suffix):
                    yield entry.path
            elif recursive and entry.is_dir():
                yield from _scandir(entry.path, suffix=suffix, recursive=recursive)

    result = list(_scandir(dir_path, suffix=suffix, recursive=recursive))
    
    if full_path:
        result = [os.path.abspath(p) for p in result]
    else:
        result = [os.path.relpath(p, root) for p in result]

    return result
'''

with open('/dbfs/FileStore/VideoReTalking/basicsr/utils/misc.py', 'w') as f:
    f.write(misc_code)

print("âœ… BasicSR utils.scandir stub created")
